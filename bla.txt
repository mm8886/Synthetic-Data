import streamlit as st
import pandas as pd
import numpy as np
import joblib
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings
warnings.filterwarnings('ignore')

# Set page config
st.set_page_config(
    page_title="Standard Chartered - Channel Prediction Model",
    page_icon="üè¶",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS with Standard Chartered branding
st.markdown("""
<style>
    /* Standard Chartered Brand Colors */
    :root {
        --sc-blue: #0F4C99;
        --sc-green: #00B04F;
        --sc-light-blue: #4A90E2;
        --sc-gray: #6B7280;
        --sc-light-gray: #F3F4F6;
        --sc-white: #FFFFFF;
    }
    
    /* Main Header */
    .main-header {
        font-size: 2.5rem;
        color: var(--sc-blue);
        text-align: center;
        margin-bottom: 1rem;
        font-weight: bold;
        font-family: 'Arial', sans-serif;
    }
    
    .sub-header {
        font-size: 1.2rem;
        color: var(--sc-gray);
        text-align: center;
        margin-bottom: 2rem;
        font-weight: 400;
    }
    
    /* Logo styling - for sidebar */
    .stImage > div {
        display: flex;
        justify-content: center;
    }
    
    /* Customer info cards */
    .customer-info {
        background-color: #FFFFFF;
        padding: 1.5rem;
        border-radius: 10px;
        border: 2px solid #E5E7EB;
        margin: 1rem 0;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }
    
    /* Prediction results */
    .prediction-result {
        background-color: #F8FAFF;
        padding: 1.5rem;
        border-radius: 10px;
        border: 2px solid var(--sc-blue);
        margin: 1rem 0;
        box-shadow: 0 4px 12px rgba(15, 76, 153, 0.15);
    }
    
    /* Channel ranking cards */
    .channel-ranking {
        background-color: #FFFFFF;
        padding: 1rem;
        border-radius: 8px;
        border: 2px solid #E5E7EB;
        margin: 0.5rem 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: #1F2937;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    /* Recommendation box */
    .recommendation-box {
        background-color: #F0FDF4;
        padding: 1.5rem;
        border-radius: 10px;
        border: 2px solid var(--sc-green);
        margin: 1rem 0;
        box-shadow: 0 2px 8px rgba(0, 176, 79, 0.1);
    }
    
    /* Sidebar styling */
    .sidebar .sidebar-content {
        background-color: var(--sc-light-gray);
    }
    
    /* Button styling */
    .stButton > button {
        background-color: var(--sc-blue);
        color: white;
        border-radius: 8px;
        border: none;
        font-weight: 500;
        transition: all 0.3s ease;
    }
    
    .stButton > button:hover {
        background-color: var(--sc-light-blue);
        box-shadow: 0 2px 8px rgba(15, 76, 153, 0.3);
    }
    
    /* Tab styling */
    .stTabs [data-baseweb="tab-list"] {
        gap: 2px;
        background-color: #F8FAFC;
        padding: 4px;
        border-radius: 8px;
    }
    
    .stTabs [data-baseweb="tab"] {
        background-color: #FFFFFF;
        border: 2px solid #E5E7EB;
        border-radius: 6px;
        color: var(--sc-blue);
        font-weight: 600;
        padding: 8px 16px;
        margin: 0 2px;
    }
    
    .stTabs [aria-selected="true"] {
        background-color: var(--sc-blue);
        color: white;
        border-color: var(--sc-blue);
    }
    
    /* Metric styling */
    [data-testid="metric-container"] {
        background-color: var(--sc-white);
        border: 1px solid var(--sc-light-gray);
        padding: 1rem;
        border-radius: 10px;
        border-left: 4px solid var(--sc-green);
    }
    
    /* Remove tab content area override - let Streamlit handle it naturally */
    
    /* Remove default streamlit padding */
    .element-container {
        margin-bottom: 0.5rem;
    }
    
    /* Fix main content area */
    .main > div {
        padding-top: 1rem;
    }
</style>
""", unsafe_allow_html=True)

class ChannelPredictor:
    """Channel prediction system exactly like the notebook implementation"""
    
    def __init__(self):
        self.model = None
        self.model_data = None
        self.df = None
        self.channels = ['SMS', 'Email', 'Call', 'WhatsApp', 'IVR', 'Field_Agent']
        self.label_encoders = {}
        
    def load_model(self, model_path):
        """Load the trained model"""
        try:
            self.model_data = joblib.load(model_path)
            self.model = self.model_data['model']
            self.channels = self.model_data.get('channels', self.channels)
            self.label_encoders = self.model_data.get('label_encoders', {})
            return True
        except Exception as e:
            st.error(f"Error loading model: {str(e)}")
            return False
    
    def load_customer_data(self, data_path):
        """Load customer dataset"""
        try:
            self.df = pd.read_csv(data_path)
            # Add estimated age for filtering
            if 'Age' in self.df.columns:
                self.df['Estimated_Age'] = (45 + self.df['Age'] * 15).clip(18, 80).astype(int)
            return True
        except Exception as e:
            st.error(f"Error loading customer data: {str(e)}")
            return False
    
    def get_customer_by_id(self, customer_id):
        """Get customer data by ID with better error handling"""
        if self.df is None:
            return None, "Customer data not loaded"
        
        customer_data = self.df[self.df['Customer_id'] == customer_id]
        
        if customer_data.empty:
            # Suggest similar customer IDs
            similar_customers = self.df[
                self.df['Customer_id'].str.contains(customer_id[:6] if len(customer_id) > 6 else customer_id[:3], 
                                                   case=False, na=False)
            ]['Customer_id'].head(5).tolist()
            
            if similar_customers:
                return None, f"Customer ID '{customer_id}' not found! Did you mean: {', '.join(similar_customers)}?"
            else:
                # Show some random samples
                random_samples = self.df['Customer_id'].sample(5).tolist()
                return None, f"Customer ID '{customer_id}' not found! Try searching or use these samples: {', '.join(random_samples)}"
        
        return customer_data.iloc[0], None
    
    def prepare_features(self, customer_data):
        """Prepare features for prediction - exactly like notebook"""
        if isinstance(customer_data, pd.Series):
            customer_data = customer_data.to_frame().T
        
        # Get feature columns (exclude label and ID columns)
        exclude_cols = ['Customer_id', 'Channel_Preference_Order', 'Preference_Label', 'Top_Channel']
        exclude_cols.extend([col for col in customer_data.columns if 'Prefers_' in col])
        feature_cols = [col for col in customer_data.columns if col not in exclude_cols]
        
        # Extract customer features
        X_customer = customer_data[feature_cols].copy()
        
        # Handle categorical encoding if needed
        for col in X_customer.columns:
            if col in self.label_encoders:
                try:
                    X_customer[col] = self.label_encoders[col].transform([X_customer[col].iloc[0]])[0]
                except:
                    X_customer[col] = 0  # Default for unseen categories
        
        return X_customer.values.flatten(), feature_cols
    
    def predict_single_customer(self, customer_data):
        """Predict channel preferences for a single customer - exactly like notebook"""
        if isinstance(customer_data, pd.Series):
            customer_data = customer_data.to_frame().T
        
        customer_id = customer_data['Customer_id'].iloc[0]
        
        # Prepare customer features
        customer_features, feature_cols = self.prepare_features(customer_data)
        
        channel_predictions = []
        
        # Make predictions for each channel
        for i, channel in enumerate(self.channels):
            try:
                # Create channel one-hot encoding
                channel_features = np.zeros(len(self.channels))
                channel_features[i] = 1
                
                # Combine customer and channel features
                combined_features = np.concatenate([customer_features, channel_features])
                
                # Make prediction
                score = self.model.predict([combined_features])[0]
                
                channel_predictions.append({
                    'channel': channel,
                    'score': score,
                    'customer_id': customer_id
                })
                
            except Exception as e:
                # Default score if prediction fails
                channel_predictions.append({
                    'channel': channel,
                    'score': 0.0,
                    'customer_id': customer_id
                })
        
        # Sort channels by prediction score (descending)
        channel_predictions.sort(key=lambda x: x['score'], reverse=True)
        
        return channel_predictions
    
    def get_customer_insights(self, customer_data):
        """Get customer profile insights with proper z-score denormalization"""
        insights = {}
        if isinstance(customer_data, pd.Series):
            data = customer_data
        else:
            data = customer_data.iloc[0]
        
        # Basic customer info
        insights['Customer ID'] = data['Customer_id']
        
        # Age (z-score denormalized) - assuming mean=45, std=15 for banking customers
        if 'Age' in data:
            z_score = data['Age']
            estimated_age = int(45 + (z_score * 15))  # mean=45, std=15
            estimated_age = max(18, min(80, estimated_age))  # Clamp to realistic range
            insights['Estimated Age'] = estimated_age
        
        # Income Band (decode z-score normalized values)
        if 'Income_Band_SGD' in data:
            z_score = data['Income_Band_SGD']
            # Map z-scores to income bands (assuming normal distribution across 6 bands)
            if z_score < -1.5:
                income_band = "50,000 or Below"
            elif z_score < -0.5:
                income_band = "50,000 to 100,000"
            elif z_score < 0.0:
                income_band = "100,000 to 200,000"
            elif z_score < 0.5:
                income_band = "200,000 to 300,000"
            elif z_score < 1.0:
                income_band = "300,000 to 500,000"
            else:
                income_band = "500,000 or Above"
            insights['Income Band (SGD)'] = income_band
        
        # Location
        if 'Urban_Rural_Tag_Urban' in data:
            insights['Location'] = "Urban" if data['Urban_Rural_Tag_Urban'] == 1.0 else "Rural"
        
        # Language Preference
        if 'Language_Preference_English' in data and 'Language_Preference_Regional' in data:
            if data['Language_Preference_English'] == 1.0:
                insights['Language Preference'] = "English"
            elif data['Language_Preference_Regional'] == 1.0:
                insights['Language Preference'] = "Regional"
            else:
                insights['Language Preference'] = "Mixed/Other"
        
        # Digital Savviness (already 0-1 scale)
        if 'Digital_Savviness_Score' in data:
            savviness = data['Digital_Savviness_Score']
            if savviness >= 0.7:
                savviness_level = f"High ({savviness:.2f})"
            elif savviness >= 0.4:
                savviness_level = f"Medium ({savviness:.2f})"
            else:
                savviness_level = f"Low ({savviness:.2f})"
            insights['Digital Savviness'] = savviness_level
        
        # App Usage (raw values)
        if 'App_Login_Frequency' in data:
            insights['App Login Frequency'] = f"{int(data['App_Login_Frequency'])} times/month"
        
        if 'Online_Banking_Activity' in data:
            insights['Online Banking Activity'] = f"{int(data['Online_Banking_Activity'])} transactions/month"
        
        # Smartphone Usage
        if 'Smartphone_Penetration_High' in data:
            insights['Smartphone Usage'] = "High" if data['Smartphone_Penetration_High'] == 1.0 else "Low/Medium"
        
        # Customer Segment
        if 'Customer_Segment' in data:
            insights['Customer Segment'] = data['Customer_Segment']
        
        # Credit Score (z-score denormalized) - assuming mean=700, std=100
        if 'Credit_Score' in data:
            z_score = data['Credit_Score']
            estimated_score = int(700 + (z_score * 100))  # mean=700, std=100
            estimated_score = max(300, min(850, estimated_score))  # Clamp to realistic range
            insights['Estimated Credit Score'] = estimated_score
        
        # Loan Information (z-score denormalized) - assuming mean=100k, std=50k
        if 'Loan_Amount_SGD' in data:
            z_score = data['Loan_Amount_SGD']
            estimated_loan = int(100000 + (z_score * 50000))  # mean=100k, std=50k
            estimated_loan = max(10000, estimated_loan)  # Minimum 10k
            insights['Estimated Loan Amount (SGD)'] = f"{estimated_loan:,}"
        
        # Outstanding Balance (z-score denormalized) - assuming mean=50k, std=30k
        if 'Outstanding_Balance_SGD' in data:
            z_score = data['Outstanding_Balance_SGD']
            estimated_balance = int(50000 + (z_score * 30000))  # mean=50k, std=30k
            estimated_balance = max(0, estimated_balance)  # Minimum 0
            insights['Estimated Outstanding Balance (SGD)'] = f"{estimated_balance:,}"
        
        # Days Past Due (z-score denormalized) - assuming mean=15, std=10
        if 'Day_Past_Due' in data:
            z_score = data['Day_Past_Due']
            estimated_dpd = int(15 + (z_score * 10))  # mean=15, std=10
            estimated_dpd = max(0, estimated_dpd)  # Minimum 0 days
            insights['Days Past Due'] = estimated_dpd
        
        # Tenure (z-score denormalized) - assuming mean=36 months, std=18 months
        if 'Tenure' in data:
            z_score = data['Tenure']
            estimated_tenure = int(36 + (z_score * 18))  # mean=36, std=18
            estimated_tenure = max(1, estimated_tenure)  # Minimum 1 month
            insights['Estimated Tenure (Months)'] = estimated_tenure
        
        # Channel Response Rates (show top channels)
        channel_rates = {}
        for channel in ['SMS', 'Email', 'Call', 'WhatsApp', 'IVR', 'Field_Agent']:
            rate_col = f'Channel_{channel}_Response_Rate'
            if rate_col in data and data[rate_col] > 0:
                channel_rates[channel] = data[rate_col]
        
        if channel_rates:
            top_responsive_channel = max(channel_rates, key=channel_rates.get)
            insights['Most Responsive Channel'] = f"{top_responsive_channel} ({channel_rates[top_responsive_channel]:.3f})"
        
        # Actual preference order if available
        if 'Channel_Preference_Order' in data:
            insights['Actual Preference Order'] = data['Channel_Preference_Order']
        
        if 'Top_Channel' in data:
            insights['Current Top Channel'] = data['Top_Channel']
        
        return insights

def main():
    # Clean main header without logo
    st.markdown('<h1 class="main-header">Channel Prediction System</h1>', unsafe_allow_html=True)
    st.markdown('<p class="sub-header">AI-Powered Customer Communication Channel Optimization</p>', unsafe_allow_html=True)
    
    # Initialize predictor
    predictor = ChannelPredictor()
    
    # Standard Chartered logo in sidebar
    logo_files = ["standard_chartered_logo.png", "standard_chartered_logo.jpg", 
                  "sc_logo.png", "logo.png", "Standard_Chartered_logo.png"]
    logo_displayed = False
    
    for logo_file in logo_files:
        try:
            st.sidebar.image(logo_file, width=220)
            logo_displayed = True
            break
        except:
            continue
    
    if not logo_displayed:
        # Fallback display for sidebar
        st.sidebar.markdown("""
        <div style='text-align: center; padding: 1rem; margin-bottom: 1rem;'>
            <div style='font-family: Arial, sans-serif;'>
                <span style='color: #0066CC; font-size: 2rem; font-weight: bold; letter-spacing: -1px;'>S</span>
                <span style='color: #666666; font-size: 1.2rem; font-weight: 300; margin-left: 0.3rem;'>standard</span><br>
                <span style='color: #666666; font-size: 1.2rem; font-weight: 300; margin-left: 1.5rem;'>chartered</span>
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # Sidebar for model selection with SC branding
    st.sidebar.markdown("""
    <div style='background: linear-gradient(135deg, #0F4C99 0%, #4A90E2 100%); 
                padding: 1rem; border-radius: 10px; margin-bottom: 1rem; text-align: center;'>
        <h3 style='color: white; margin: 0;'>‚öôÔ∏è Model Settings</h3>
        <p style='color: #E3F2FD; margin: 0.5rem 0 0 0; font-size: 0.9rem;'>Standard Chartered AI</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Model selection
    model_option = st.sidebar.selectbox(
        "Select Prediction Model:",
        ["LightGBM (Recommended)", "XGBoost", "Random Forest"]
    )
    
    model_files = {
        "LightGBM (Recommended)": "lightgbm_channel_ranker.pkl",
        "XGBoost": "xgb_channel_ranker.pkl", 
        "Random Forest": "random_forest_channel_ranker.pkl"
    }
    
    selected_model_file = model_files[model_option]
    
    # Load model and data
    if st.sidebar.button("üîÑ Load Model & Data"):
        with st.spinner("Loading model and customer data..."):
            model_loaded = predictor.load_model(selected_model_file)
            data_loaded = predictor.load_customer_data('features_with_labels.csv')
            
            if model_loaded and data_loaded:
                st.sidebar.success(f"‚úÖ {model_option} loaded successfully!")
                st.sidebar.success(f"‚úÖ {len(predictor.df):,} customers loaded!")
                st.session_state.model_loaded = True
                st.session_state.current_model = model_option
                st.session_state.predictor = predictor
            else:
                st.sidebar.error("‚ùå Failed to load model or data")
                st.session_state.model_loaded = False
    
    # Check if model is loaded
    if not hasattr(st.session_state, 'model_loaded') or not st.session_state.model_loaded:
        st.warning("‚ö†Ô∏è Please load a model and data from the sidebar to start making predictions.")
        
        # Show instructions
        st.info("""
        **Instructions:**
        1. Select a model from the sidebar (LightGBM recommended)
        2. Click 'Load Model & Data' to initialize the system
        3. Enter a Customer ID to get channel predictions
        """)
        return
    
    # Get predictor from session state
    predictor = st.session_state.predictor
    
    # Show prediction mode buttons
    col_btn1, col_btn2 = st.columns(2)
    with col_btn1:
        if st.button("Individual Prediction"):
            st.session_state.mode = "individual"
    with col_btn2:
        if st.button("Batch Prediction"):
            st.session_state.mode = "batch"
    
    mode = st.session_state.get('mode', None)
    
    if mode == "batch":
        st.write("Under Development")
        return
    elif mode != "individual":
        return
    
    # Individual prediction interface
    st.subheader("üîç Customer Search & Selection")
    
    # Search or enter customer ID with predict button beside it
    col_id, col_predict = st.columns([4, 1])
    with col_id:
        customer_id_input = st.text_input(
            "Search or Enter Customer ID:",
            value=st.session_state.get('customer_id', ''),
            placeholder="Type to search or enter (e.g., SCB251079598)",
            help="Search through all 100,000+ customers or enter directly"
        )
    with col_predict:
        predict_clicked = st.button("üéØ Predict")
    
    # Quick validation
    if customer_id_input and predictor.df is not None:
        if customer_id_input in predictor.df['Customer_id'].values:
            st.success(f"‚úÖ Customer {customer_id_input} found in database!")
        elif len(customer_id_input) > 3:
            st.warning(f"‚ö†Ô∏è Customer {customer_id_input} not found. Check spelling or search above.")
    
    # Integrate advanced search
    st.subheader("Advanced Filters (Filter by Segment & Age Range)")
    col_f1, col_f2, col_f3 = st.columns(3)
    
    with col_f1:
        if 'Customer_Segment' in predictor.df.columns:
            segment_options = ['All'] + predictor.df['Customer_Segment'].unique().tolist()
            selected_segment = st.selectbox("Filter by Segment:", segment_options)
        else:
            selected_segment = 'All'
    
    with col_f2:
        min_age, max_age = st.slider("Estimated Age Range:", 18, 80, (18, 80))
    
    with col_f3:
        id_pattern = st.text_input("Customer ID Pattern:", placeholder="e.g., SCB2*, *598, SCB*")
    
    if st.button("üîç Apply Filters"):
        # Apply filters
        filtered_df = predictor.df.copy()
        
        if selected_segment != 'All':
            filtered_df = filtered_df[filtered_df['Customer_Segment'] == selected_segment]
        
        if 'Estimated_Age' in filtered_df.columns:
            filtered_df = filtered_df[(filtered_df['Estimated_Age'] >= min_age) & (filtered_df['Estimated_Age'] <= max_age)]
        
        if id_pattern:
            # Convert pattern to regex
            regex_pattern = id_pattern.replace('*', '.*')
            filtered_df = filtered_df[
                filtered_df['Customer_id'].str.match(regex_pattern, case=False, na=False)
            ]
        
        search_results = filtered_df['Customer_id'].head(40).tolist()
        
        if search_results:
            st.success(f"Found {len(filtered_df)} customers (showing first 40):")
            cols = st.columns(5)
            for i, cust_id in enumerate(search_results):
                with cols[i % 5]:
                    if st.button(cust_id, key=f"adv_search_{cust_id}"):
                        st.session_state.customer_id = cust_id
                        st.rerun()
        else:
            st.warning("No customers found with these criteria")
    
    # Show 30 random customers button
    if st.button("üé≤ Show 30 Random Customers"):
        sample_customers = predictor.df['Customer_id'].sample(30).tolist()
        st.write("üí° Click any sample Customer ID below:")
        cols = st.columns(6)
        for i, customer_id in enumerate(sample_customers):
            with cols[i % 6]:
                if st.button(customer_id, key=f"sample_btn_{customer_id}"):
                    st.session_state.customer_id = customer_id
                    st.rerun()
    
    # Show dataset statistics
    st.info(f"üìä **Dataset Info:** {len(predictor.df):,} total customers available for prediction")
    
    # Handle prediction
    if predict_clicked and customer_id_input:
        with st.spinner("Looking up customer and generating predictions..."):
            # Get customer data
            customer_data, error = predictor.get_customer_by_id(customer_id_input)
            
            if error:
                st.error(error)
            else:
                # Make predictions
                predictions = predictor.predict_single_customer(customer_data)
                insights = predictor.get_customer_insights(customer_data)
                
                # Store in session state
                st.session_state.predictions = predictions
                st.session_state.customer_insights = insights
                st.session_state.current_customer_id = customer_id_input
                
                st.success(f"‚úÖ Predictions generated for Customer {customer_id_input}!")

    # Prediction results container below
    if hasattr(st.session_state, 'predictions') and st.session_state.predictions:
        st.header("üéØ Prediction Results")
        
        # Display current model and customer
        st.info(f"ü§ñ Model: {st.session_state.current_model}")
        st.info(f"üë§ Customer: {st.session_state.current_customer_id}")
        
        # Customer insights (remove Channels tab)
        if hasattr(st.session_state, 'customer_insights'):
            st.markdown('<div class="customer-info">', unsafe_allow_html=True)
            st.subheader("üë§ Customer Profile Details")
            
            insights = st.session_state.customer_insights
            
            # Organize insights into categories (remove channel_info)
            basic_info = {}
            financial_info = {}
            digital_info = {}
            
            for key, value in insights.items():
                if key in ['Customer ID', 'Estimated Age', 'Location', 'Language Preference', 'Customer Segment']:
                    basic_info[key] = value
                elif 'Loan' in key or 'Credit' in key or 'Balance' in key or 'Due' in key or 'Tenure' in key or 'Income' in key:
                    financial_info[key] = value
                elif 'Digital' in key or 'App' in key or 'Online' in key or 'Smartphone' in key:
                    digital_info[key] = value
                # Skip channel_info
            
            # Display in organized tabs (remove Channels)
            info_tab1, info_tab2, info_tab3 = st.tabs(["üë§ Basic", "üí∞ Financial", "üì± Digital"])
            
            with info_tab1:
                for key, value in basic_info.items():
                    st.write(f"**{key}:** {value}")
            
            with info_tab2:
                for key, value in financial_info.items():
                    st.write(f"**{key}:** {value}")
            
            with info_tab3:
                for key, value in digital_info.items():
                    st.write(f"**{key}:** {value}")
            
            st.markdown('</div>', unsafe_allow_html=True)
        
        # Primary recommendation
        predictions = st.session_state.predictions
        top_channel = predictions[0]['channel']
        top_score = predictions[0]['score']
        
        st.markdown(f"""
        <div class="recommendation-box">
            <h4 style='color: #00B04F; margin-bottom: 1rem;'>üéØ Primary Recommendation</h4>
            <div style='background-color: white; padding: 1rem; border-radius: 8px; border: 2px solid #00B04F;'>
                <p style='font-size: 1.1rem; font-weight: bold; color: #0F4C99; margin-bottom: 0.5rem;'>
                    üìû Contact via: {top_channel}
                </p>
                <p style='color: #6B7280; margin: 0;'>Confidence Score: {top_score:.4f}</p>
            </div>
        </div>
        """, unsafe_allow_html=True)
        
        # Business Action Plan (full content, no expander)
        st.subheader("üíº Business Action Plan")
        st.write("**Recommended Contact Strategy:**")
        st.write(f"1. **Start with {predictions[0]['channel']}** - Highest success probability")
        st.write(f"2. **Follow up with {predictions[1]['channel']}** - Second best option")
        st.write(f"3. **Use {predictions[2]['channel']}** - Alternative if needed")
        
        st.write("\n**Channel Insights:**")
        for i, pred in enumerate(predictions[:3]):
            effectiveness = "High" if pred['score'] > 0 else "Medium" if pred['score'] > -1 else "Low"
            st.write(f"‚Ä¢ **{pred['channel']}**: {effectiveness} effectiveness (Score: {pred['score']:.3f})")
        
        # Channel rankings (horizontal)
        st.subheader("üìà Channel Preference Ranking")
        cols = st.columns(6)
        for i, pred in enumerate(predictions):
            with cols[i]:
                # Standard Chartered color scheme for rankings
                sc_colors = ["#00B04F", "#0F4C99", "#4A90E2", "#6B7280", "#9CA3AF", "#D1D5DB"]
                color = sc_colors[i] if i < len(sc_colors) else "#D1D5DB"
                
                # Create star rating based on score
                score = pred['score']
                stars = "‚≠ê" * max(1, min(5, int(score + 3)))
                
                # Ranking badges
                rank_badge = "ü•á" if i == 0 else "ü•à" if i == 1 else "ü•â" if i == 2 else f"{i+1}Ô∏è‚É£"
                
                st.markdown(f"""
                <div style='margin: 0.8rem 0; padding: 1.2rem; 
                           background-color: #FFFFFF;
                           border: 2px solid {color}; border-radius: 10px;
                           box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);'>
                    <div style='display: flex; justify-content: space-between; align-items: center;'>
                        <div>
                            <strong style='font-size: 1.2rem; color: {color};'>{rank_badge} {pred['channel']}</strong><br>
                            <span style='color: #6B7280; font-size: 0.9rem;'>Score: {score:.4f}</span>
                        </div>
                        <div style='font-size: 1.5rem;'>{stars}</div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
        
        # Visualization
        st.subheader("üìä Score Visualization")
        
        # Create horizontal bar chart
        channels = [pred['channel'] for pred in predictions]
        scores = [pred['score'] for pred in predictions]
        
        # Standard Chartered color palette for charts
        sc_color_scale = [
            [0.0, '#D1D5DB'],   # Light gray for low scores
            [0.3, '#9CA3AF'],   # Medium gray
            [0.5, '#6B7280'],   # Dark gray  
            [0.7, '#4A90E2'],   # SC Light blue
            [0.9, '#0F4C99'],   # SC Blue
            [1.0, '#00B04F']    # SC Green for highest scores
        ]
        
        fig = px.bar(
            x=scores, 
            y=channels, 
            orientation='h',
            title="Channel Preference Scores",
            labels={'x': 'Prediction Score', 'y': 'Communication Channel'},
            color=scores,
            color_continuous_scale=sc_color_scale,
            text=[f"{score:.3f}" for score in scores]
        )
        
        fig.update_layout(
            height=400,
            yaxis={'categoryorder': 'total ascending'},
            showlegend=False,
            title_font_color='#0F4C99',
            title_font_size=16,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)'
        )
        
        # Update axis colors
        fig.update_xaxes(gridcolor='#E5E7EB', title_font_color='#6B7280')
        fig.update_yaxes(title_font_color='#6B7280')
        
        fig.update_traces(textposition='outside')
        
        st.plotly_chart(fig, use_container_width=True)
    
    # Footer with Standard Chartered branding
    st.markdown("---")
    st.markdown("""
    <div style='background: linear-gradient(135deg, #0F4C99 0%, #00B04F 100%); 
                padding: 2rem; border-radius: 10px; text-align: center; margin-top: 2rem;'>
        <div style='color: white; font-size: 1.1rem; font-weight: bold; margin-bottom: 0.5rem;'>
            üè¶ Standard Chartered Bank
        </div>
        <div style='color: #E3F2FD; font-size: 0.9rem; margin-bottom: 0.5rem;'>
            AI-Powered Channel Prediction System
        </div>
        <div style='color: #B8E6B8; font-size: 0.8rem;'>
            Optimizing customer communication through machine learning ‚Ä¢ Powered by LightGBM, XGBoost & Random Forest
        </div>
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()