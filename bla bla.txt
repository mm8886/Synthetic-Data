import streamlit as st
import pandas as pd
import numpy as np
import joblib
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings
warnings.filterwarnings('ignore')

# Set page config
st.set_page_config(
    page_title="Standard Chartered - Channel Prediction Model",
    page_icon="üè¶",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS with Standard Chartered branding
st.markdown("""
<style>
    /* Standard Chartered Brand Colors */
    :root {
        --sc-blue: #0F4C99;
        --sc-green: #00B04F;
        --sc-light-blue: #4A90E2;
        --sc-gray: #6B7280;
        --sc-light-gray: #F3F4F6;
        --sc-white: #FFFFFF;
    }
    
    /* Main Header */
    .main-header {
        font-size: 2.5rem;
        color: var(--sc-blue);
        text-align: center;
        margin-bottom: 1rem;
        font-weight: bold;
        font-family: 'Arial', sans-serif;
    }
    
    .sub-header {
        font-size: 1.2rem;
        color: var(--sc-gray);
        text-align: center;
        margin-bottom: 2rem;
        font-weight: 400;
    }
    
    /* Logo styling - for sidebar */
    .stImage > div {
        display: flex;
        justify-content: center;
    }
    
    /* Customer info cards */
    .customer-info {
        background-color: #FFFFFF;
        padding: 1.5rem;
        border-radius: 10px;
        border: 2px solid #E5E7EB;
        margin: 1rem 0;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }
    
    /* Prediction results */
    .prediction-result {
        background-color: #F8FAFF;
        padding: 1.5rem;
        border-radius: 10px;
        border: 2px solid var(--sc-blue);
        margin: 1rem 0;
        box-shadow: 0 4px 12px rgba(15, 76, 153, 0.15);
    }
    
    /* Channel ranking cards */
    .channel-ranking {
        background-color: #FFFFFF;
        padding: 1rem;
        border-radius: 8px;
        border: 2px solid #E5E7EB;
        margin: 0.5rem 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: #1F2937;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    /* Recommendation box */
    .recommendation-box {
        background-color: #F0FDF4;
        padding: 1.5rem;
        border-radius: 10px;
        border: 2px solid var(--sc-green);
        margin: 1rem 0;
        box-shadow: 0 2px 8px rgba(0, 176, 79, 0.1);
    }
    
    /* Sidebar styling */
    .sidebar .sidebar-content {
        background-color: var(--sc-light-gray);
    }
    
    /* Button styling */
    .stButton > button {
        background-color: var(--sc-blue);
        color: white;
        border-radius: 8px;
        border: none;
        font-weight: 500;
        transition: all 0.3s ease;
    }
    
    .stButton > button:hover {
        background-color: var(--sc-light-blue);
        box-shadow: 0 2px 8px rgba(15, 76, 153, 0.3);
    }
    
    /* Tab styling */
    .stTabs [data-baseweb="tab-list"] {
        gap: 2px;
        background-color: #F8FAFC;
        padding: 4px;
        border-radius: 8px;
    }
    
    .stTabs [data-baseweb="tab"] {
        background-color: #FFFFFF;
        border: 2px solid #E5E7EB;
        border-radius: 6px;
        color: var(--sc-blue);
        font-weight: 600;
        padding: 8px 16px;
        margin: 0 2px;
    }
    
    .stTabs [aria-selected="true"] {
        background-color: var(--sc-blue);
        color: white;
        border-color: var(--sc-blue);
    }
    
    /* Metric styling */
    [data-testid="metric-container"] {
        background-color: var(--sc-white);
        border: 1px solid var(--sc-light-gray);
        padding: 1rem;
        border-radius: 10px;
        border-left: 4px solid var(--sc-green);
    }
    
    /* Remove tab content area override - let Streamlit handle it naturally */
    
    /* Remove default streamlit padding */
    .element-container {
        margin-bottom: 0.5rem;
    }
    
    /* Fix main content area */
    .main > div {
        padding-top: 1rem;
    }
    
    /* Horizontal channel tiles */
    .horizontal-tile-container {
        display: flex;
        gap: 10px;
        overflow-x: auto;
        padding: 10px 0;
        margin: 1rem 0;
    }
    
    .channel-tile {
        flex: 0 0 auto;
        width: 150px;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .tile-rank-1 {
        background-color: #00B04F;
        color: white;
    }
    
    .tile-rank-2 {
        background-color: #0F4C99;
        color: white;
    }
    
    .tile-rank-3 {
        background-color: #4A90E2;
        color: white;
    }
    
    .tile-rank-other {
        background-color: #F3F4F6;
        color: #1F2937;
    }
</style>
""", unsafe_allow_html=True)

class ChannelPredictor:
    """Channel prediction system exactly like the notebook implementation"""
    
    def __init__(self):
        self.model = None
        self.model_data = None
        self.df = None
        self.channels = ['SMS', 'Email', 'Call', 'WhatsApp', 'IVR', 'Field_Agent']
        self.label_encoders = {}
        
    def load_model(self, model_path):
        """Load the trained model"""
        try:
            self.model_data = joblib.load(model_path)
            self.model = self.model_data['model']
            self.channels = self.model_data.get('channels', self.channels)
            self.label_encoders = self.model_data.get('label_encoders', {})
            return True
        except Exception as e:
            st.error(f"Error loading model: {str(e)}")
            return False
    
    def load_customer_data(self, data_path):
        """Load customer dataset"""
        try:
            self.df = pd.read_csv(data_path)
            return True
        except Exception as e:
            st.error(f"Error loading customer data: {str(e)}")
            return False
    
    def get_customer_by_id(self, customer_id):
        """Get customer data by ID with better error handling"""
        if self.df is None:
            return None, "Customer data not loaded"
        
        customer_data = self.df[self.df['Customer_id'] == customer_id]
        
        if customer_data.empty:
            # Suggest similar customer IDs
            similar_customers = self.df[
                self.df['Customer_id'].str.contains(customer_id[:6] if len(customer_id) > 6 else customer_id[:3], 
                                                   case=False, na=False)
            ]['Customer_id'].head(5).tolist()
            
            if similar_customers:
                return None, f"Customer ID '{customer_id}' not found! Did you mean: {', '.join(similar_customers)}?"
            else:
                # Show some random samples
                random_samples = self.df['Customer_id'].sample(5).tolist()
                return None, f"Customer ID '{customer_id}' not found! Try searching or use these samples: {', '.join(random_samples)}"
        
        return customer_data.iloc[0], None
    
    def prepare_features(self, customer_data):
        """Prepare features for prediction - exactly like notebook"""
        if isinstance(customer_data, pd.Series):
            customer_data = customer_data.to_frame().T
        
        # Get feature columns (exclude label and ID columns)
        exclude_cols = ['Customer_id', 'Channel_Preference_Order', 'Preference_Label', 'Top_Channel']
        exclude_cols.extend([col for col in customer_data.columns if 'Prefers_' in col])
        feature_cols = [col for col in customer_data.columns if col not in exclude_cols]
        
        # Extract customer features
        X_customer = customer_data[feature_cols].copy()
        
        # Handle categorical encoding if needed
        for col in X_customer.columns:
            if col in self.label_encoders:
                try:
                    X_customer[col] = self.label_encoders[col].transform([X_customer[col].iloc[0]])[0]
                except:
                    X_customer[col] = 0  # Default for unseen categories
        
        return X_customer.values.flatten(), feature_cols
    
    def predict_single_customer(self, customer_data):
        """Predict channel preferences for a single customer - exactly like notebook"""
        if isinstance(customer_data, pd.Series):
            customer_data = customer_data.to_frame().T
        
        customer_id = customer_data['Customer_id'].iloc[0]
        
        # Prepare customer features
        customer_features, feature_cols = self.prepare_features(customer_data)
        
        channel_predictions = []
        
        # Make predictions for each channel
        for i, channel in enumerate(self.channels):
            try:
                # Create channel one-hot encoding
                channel_features = np.zeros(len(self.channels))
                channel_features[i] = 1
                
                # Combine customer and channel features
                combined_features = np.concatenate([customer_features, channel_features])
                
                # Make prediction
                score = self.model.predict([combined_features])[0]
                
                channel_predictions.append({
                    'channel': channel,
                    'score': score,
                    'customer_id': customer_id
                })
                
            except Exception as e:
                # Default score if prediction fails
                channel_predictions.append({
                    'channel': channel,
                    'score': 0.0,
                    'customer_id': customer_id
                })
        
        # Sort channels by prediction score (descending)
        channel_predictions.sort(key=lambda x: x['score'], reverse=True)
        
        return channel_predictions
    
    def get_customer_insights(self, customer_data):
        """Get customer profile insights with proper z-score denormalization"""
        insights = {}
        if isinstance(customer_data, pd.Series):
            data = customer_data
        else:
            data = customer_data.iloc[0]
        
        # Basic customer info
        insights['Customer ID'] = data['Customer_id']
        
        # Age (z-score denormalized) - assuming mean=45, std=15 for banking customers
        if 'Age' in data:
            z_score = data['Age']
            estimated_age = int(45 + (z_score * 15))  # mean=45, std=15
            estimated_age = max(18, min(80, estimated_age))  # Clamp to realistic range
            insights['Estimated Age'] = estimated_age
        
        # Income Band (decode z-score normalized values)
        if 'Income_Band_SGD' in data:
            z_score = data['Income_Band_SGD']
            # Map z-scores to income bands (assuming normal distribution across 6 bands)
            if z_score < -1.5:
                income_band = "50,000 or Below"
            elif z_score < -0.5:
                income_band = "50,000 to 100,000"
            elif z_score < 0.0:
                income_band = "100,000 to 200,000"
            elif z_score < 0.5:
                income_band = "200,000 to 300,000"
            elif z_score < 1.0:
                income_band = "300,000 to 500,000"
            else:
                income_band = "500,000 or Above"
            insights['Income Band (SGD)'] = income_band
        
        # Location
        if 'Urban_Rural_Tag_Urban' in data:
            insights['Location'] = "Urban" if data['Urban_Rural_Tag_Urban'] == 1.0 else "Rural"
        
        # Language Preference
        if 'Language_Preference_English' in data and 'Language_Preference_Regional' in data:
            if data['Language_Preference_English'] == 1.0:
                insights['Language Preference'] = "English"
            elif data['Language_Preference_Regional'] == 1.0:
                insights['Language Preference'] = "Regional"
            else:
                insights['Language Preference'] = "Mixed/Other"
        
        # Digital Savviness (already 0-1 scale)
        if 'Digital_Savviness_Score' in data:
            savviness = data['Digital_Savviness_Score']
            if savviness >= 0.7:
                savviness_level = f"High ({savviness:.2f})"
            elif savviness >= 0.4:
                savviness_level = f"Medium ({savviness:.2f})"
            else:
                savviness_level = f"Low ({savviness:.2f})"
            insights['Digital Savviness'] = savviness_level
        
        # App Usage (raw values)
        if 'App_Login_Frequency' in data:
            insights['App Login Frequency'] = f"{int(data['App_Login_Frequency'])} times/month"
        
        if 'Online_Banking_Activity' in data:
            insights['Online Banking Activity'] = f"{int(data['Online_Banking_Activity'])} transactions/month"
        
        # Smartphone Usage
        if 'Smartphone_Penetration_High' in data:
            insights['Smartphone Usage'] = "High" if data['Smartphone_Penetration_High'] == 1.0 else "Low/Medium"
        
        # Customer Segment
        if 'Customer_Segment' in data:
            insights['Customer Segment'] = data['Customer_Segment']
        
        # Credit Score (z-score denormalized) - assuming mean=700, std=100
        if 'Credit_Score' in data:
            z_score = data['Credit_Score']
            estimated_score = int(700 + (z_score * 100))  # mean=700, std=100
            estimated_score = max(300, min(850, estimated_score))  # Clamp to realistic range
            insights['Estimated Credit Score'] = estimated_score
        
        # Loan Information (z-score denormalized) - assuming mean=100k, std=50k
        if 'Loan_Amount_SGD' in data:
            z_score = data['Loan_Amount_SGD']
            estimated_loan = int(100000 + (z_score * 50000))  # mean=100k, std=50k
            estimated_loan = max(10000, estimated_loan)  # Minimum 10k
            insights['Estimated Loan Amount (SGD)'] = f"{estimated_loan:,}"
        
        # Outstanding Balance (z-score denormalized) - assuming mean=50k, std=30k
        if 'Outstanding_Balance_SGD' in data:
            z_score = data['Outstanding_Balance_SGD']
            estimated_balance = int(50000 + (z_score * 30000))  # mean=50k, std=30k
            estimated_balance = max(0, estimated_balance)  # Minimum 0
            insights['Estimated Outstanding Balance (SGD)'] = f"{estimated_balance:,}"
        
        # Days Past Due (z-score denormalized) - assuming mean=15, std=10
        if 'Day_Past_Due' in data:
            z_score = data['Day_Past_Due']
            estimated_dpd = int(15 + (z_score * 10))  # mean=15, std=10
            estimated_dpd = max(0, estimated_dpd)  # Minimum 0 days
            insights['Days Past Due'] = estimated_dpd
        
        # Tenure (z-score denormalized) - assuming mean=36 months, std=18 months
        if 'Tenure' in data:
            z_score = data['Tenure']
            estimated_tenure = int(36 + (z_score * 18))  # mean=36, std=18
            estimated_tenure = max(1, estimated_tenure)  # Minimum 1 month
            insights['Estimated Tenure (Months)'] = estimated_tenure
        
        # Channel Response Rates (show top channels)
        channel_rates = {}
        for channel in ['SMS', 'Email', 'Call', 'WhatsApp', 'IVR', 'Field_Agent']:
            rate_col = f'Channel_{channel}_Response_Rate'
            if rate_col in data and data[rate_col] > 0:
                channel_rates[channel] = data[rate_col]
        
        if channel_rates:
            top_responsive_channel = max(channel_rates, key=channel_rates.get)
            insights['Most Responsive Channel'] = f"{top_responsive_channel} ({channel_rates[top_responsive_channel]:.3f})"
        
        # Actual preference order if available
        if 'Channel_Preference_Order' in data:
            insights['Actual Preference Order'] = data['Channel_Preference_Order']
        
        if 'Top_Channel' in data:
            insights['Current Top Channel'] = data['Top_Channel']
        
        return insights

def main():
    # Clean main header without logo
    st.markdown('<h1 class="main-header">Channel Prediction System</h1>', unsafe_allow_html=True)
    st.markdown('<p class="sub-header">AI-Powered Customer Communication Channel Optimization</p>', unsafe_allow_html=True)
    
    # Initialize predictor
    predictor = ChannelPredictor()
    
    # Standard Chartered logo in sidebar
    logo_files = ["standard_chartered_logo.png", "standard_chartered_logo.jpg", 
                  "sc_logo.png", "logo.png", "Standard_Chartered_logo.png"]
    logo_displayed = False
    
    for logo_file in logo_files:
        try:
            st.sidebar.image(logo_file, width=220)
            logo_displayed = True
            break
        except:
            continue
    
    if not logo_displayed:
        # Fallback display for sidebar
        st.sidebar.markdown("""
        <div style='text-align: center; padding: 1rem; margin-bottom: 1rem;'>
            <div style='font-family: Arial, sans-serif;'>
                <span style='color: #0066CC; font-size: 2rem; font-weight: bold; letter-spacing: -1px;'>S</span>
                <span style='color: #666666; font-size: 1.2rem; font-weight: 300; margin-left: 0.3rem;'>standard</span><br>
                <span style='color: #666666; font-size: 1.2rem; font-weight: 300; margin-left: 1.5rem;'>chartered</span>
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # Sidebar for model selection with SC branding
    st.sidebar.markdown("""
    <div style='background: linear-gradient(135deg, #0F4C99 0%, #4A90E2 100%); 
                padding: 1rem; border-radius: 10px; margin-bottom: 1rem; text-align: center;'>
        <h3 style='color: white; margin: 0;'>‚öôÔ∏è Model Settings</h3>
        <p style='color: #E3F2FD; margin: 0.5rem 0 0 0; font-size: 0.9rem;'>Standard Chartered AI</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Model selection
    model_option = st.sidebar.selectbox(
        "Select Prediction Model:",
        ["LightGBM (Recommended)", "XGBoost", "Random Forest"]
    )
    
    model_files = {
        "LightGBM (Recommended)": "lightgbm_channel_ranker.pkl",
        "XGBoost": "xgb_channel_ranker.pkl", 
        "Random Forest": "random_forest_channel_ranker.pkl"
    }
    
    selected_model_file = model_files[model_option]
    
    # Load model and data
    if st.sidebar.button("üîÑ Load Model & Data"):
        with st.spinner("Loading model and customer data..."):
            model_loaded = predictor.load_model(selected_model_file)
            data_loaded = predictor.load_customer_data('features_with_labels.csv')
            
            if model_loaded and data_loaded:
                st.sidebar.success(f"‚úÖ {model_option} loaded successfully!")
                st.sidebar.success(f"‚úÖ {len(predictor.df):,} customers loaded!")
                st.session_state.model_loaded = True
                st.session_state.current_model = model_option
                st.session_state.predictor = predictor
                
                # Show prediction type selection after loading
                st.session_state.show_prediction_type = True
            else:
                st.sidebar.error("‚ùå Failed to load model or data")
                st.session_state.model_loaded = False
                st.session_state.show_prediction_type = False
    
    # Check if model is loaded and show prediction type selection
    if hasattr(st.session_state, 'show_prediction_type') and st.session_state.show_prediction_type:
        st.markdown("---")
        st.subheader("üéØ Select Prediction Type")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üë§ Individual Prediction", use_container_width=True, type="primary"):
                st.session_state.prediction_type = "individual"
                st.rerun()
        
        with col2:
            if st.button("üìä Batch Prediction", use_container_width=True):
                st.session_state.prediction_type = "batch"
                st.rerun()
    
    # Handle batch prediction
    if hasattr(st.session_state, 'prediction_type') and st.session_state.prediction_type == "batch":
        st.markdown("---")
        st.info("üìä Batch Prediction - Under Development")
        st.warning("This feature is currently under development and will be available in the next release.")
        
        if st.button("‚Üê Back to Individual Prediction"):
            st.session_state.prediction_type = "individual"
            st.rerun()
        return
    
    # Individual prediction interface
    if hasattr(st.session_state, 'prediction_type') and st.session_state.prediction_type == "individual":
        # Get predictor from session state
        predictor = st.session_state.predictor
        
        # Search and prediction section
        st.markdown("---")
        
        # Create two columns for search and prediction button
        search_col, predict_col = st.columns([3, 1])
        
        with search_col:
            # Integrated search with advanced options
            customer_id_input = st.text_input(
                "üîç Search Customer ID:",
                value=st.session_state.get('selected_customer_id', ''),
                placeholder="Type any Customer ID (e.g., SCB251079598) or use advanced search below",
                help="Enter ANY Customer ID from the 100,000+ customers in the dataset"
            )
        
        with predict_col:
            st.write("")  # Spacer for alignment
            st.write("")  # Spacer for alignment
            if st.button("üéØ Predict Channel Preferences", type="primary", use_container_width=True):
                if customer_id_input:
                    with st.spinner("Looking up customer and generating predictions..."):
                        # Get customer data
                        customer_data, error = predictor.get_customer_by_id(customer_id_input)
                        
                        if error:
                            st.error(error)
                        else:
                            # Make predictions
                            predictions = predictor.predict_single_customer(customer_data)
                            insights = predictor.get_customer_insights(customer_data)
                            
                            # Store in session state
                            st.session_state.predictions = predictions
                            st.session_state.customer_insights = insights
                            st.session_state.current_customer_id = customer_id_input
                            
                            st.success(f"‚úÖ Predictions generated for Customer {customer_id_input}!")
                else:
                    st.warning("Please enter a Customer ID")
        
        # Advanced search options
        with st.expander("üîç Advanced Search Options", expanded=True):
            col1, col2 = st.columns(2)
            
            with col1:
                # Filter by segment
                if 'Customer_Segment' in predictor.df.columns:
                    segment_options = ['All'] + predictor.df['Customer_Segment'].unique().tolist()
                    selected_segment = st.selectbox("Filter by Segment:", segment_options)
                else:
                    selected_segment = 'All'
                
                # Age range filter
                st.write("Age Range: 18-80 years")
            
            with col2:
                # Search by ID pattern
                id_pattern = st.text_input("Customer ID Pattern:", placeholder="e.g., SCB2*, *598, SCB*")
            
            # Show random customers button
            if st.button("üé≤ Show 30 Random Customers"):
                st.session_state.random_customers = predictor.df['Customer_id'].sample(30).tolist()
            
            # Display random customers if available
            if hasattr(st.session_state, 'random_customers') and st.session_state.random_customers:
                st.write("**Click any Customer ID below to select:**")
                
                # Display in a grid
                cols = st.columns(6)
                for i, customer_id in enumerate(st.session_state.random_customers):
                    with cols[i % 6]:
                        if st.button(customer_id, key=f"rand_btn_{customer_id}", use_container_width=True):
                            st.session_state.selected_customer_id = customer_id
                            st.rerun()
        
        # Quick validation
        if customer_id_input and predictor.df is not None:
            if customer_id_input in predictor.df['Customer_id'].values:
                st.success(f"‚úÖ Customer {customer_id_input} found in database!")
            elif len(customer_id_input) > 3:
                st.warning(f"‚ö†Ô∏è Customer {customer_id_input} not found. Check spelling or search above.")
        
        # Show dataset statistics
        st.info(f"üìä **Dataset Info:** {len(predictor.df):,} total customers available for prediction")
        
        # Prediction results container
        if hasattr(st.session_state, 'predictions') and st.session_state.predictions:
            st.markdown("---")
            st.subheader("üìä Prediction Results")
            
            # Display current model and customer
            st.info(f"ü§ñ Model: {st.session_state.current_model} | üë§ Customer: {st.session_state.current_customer_id}")
            
            # Customer Profile Details
            if hasattr(st.session_state, 'customer_insights'):
                st.markdown('<div class="customer-info">', unsafe_allow_html=True)
                st.subheader("üë§ Customer Profile Details")
                
                insights = st.session_state.customer_insights
                
                # Organize insights into categories (excluding channels)
                basic_info = {}
                financial_info = {}
                digital_info = {}
                
                for key, value in insights.items():
                    if key in ['Customer ID', 'Estimated Age', 'Location', 'Language Preference', 'Customer Segment']:
                        basic_info[key] = value
                    elif 'Loan' in key or 'Credit' in key or 'Balance' in key or 'Due' in key or 'Tenure' in key or 'Income' in key:
                        financial_info[key] = value
                    elif 'Digital' in key or 'App' in key or 'Online' in key or 'Smartphone' in key:
                        digital_info[key] = value
                
                # Display in organized columns
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.write("**Basic Information**")
                    for key, value in basic_info.items():
                        st.write(f"**{key}:** {value}")
                
                with col2:
                    st.write("**Financial Information**")
                    for key, value in financial_info.items():
                        st.write(f"**{key}:** {value}")
                
                with col3:
                    st.write("**Digital Profile**")
                    for key, value in digital_info.items():
                        st.write(f"**{key}:** {value}")
                
                st.markdown('</div>', unsafe_allow_html=True)
            
            # Primary Recommendation and Business Action Plan
            predictions = st.session_state.predictions
            top_channel = predictions[0]['channel']
            top_score = predictions[0]['score']
            
            # Primary Recommendation
            st.markdown(f"""
            <div class="recommendation-box">
                <h4 style='color: #00B04F; margin-bottom: 1rem;'>üéØ Primary Recommendation</h4>
                <div style='background-color: white; padding: 1rem; border-radius: 8px; border: 2px solid #00B04F;'>
                    <p style='font-size: 1.1rem; font-weight: bold; color: #0F4C99; margin-bottom: 0.5rem;'>
                        üìû Contact via: {top_channel}
                    </p>
                    <p style='color: #6B7280; margin: 0;'>Confidence Score: {top_score:.4f}</p>
                </div>
            </div>
            """, unsafe_allow_html=True)
            
            # Business Action Plan (full content, no expander)
            st.markdown("""
            <div style='background-color: #F8FAFF; padding: 1.5rem; border-radius: 10px; border: 2px solid #0F4C99; margin: 1rem 0;'>
                <h4 style='color: #0F4C99; margin-bottom: 1rem;'>üíº Business Action Plan</h4>
            """, unsafe_allow_html=True)
            
            st.write("**Recommended Contact Strategy:**")
            st.write(f"1. **Start with {predictions[0]['channel']}** - Highest success probability (Score: {predictions[0]['score']:.3f})")
            st.write(f"2. **Follow up with {predictions[1]['channel']}** - Second best option (Score: {predictions[1]['score']:.3f})")
            st.write(f"3. **Use {predictions[2]['channel']}** - Alternative if needed (Score: {predictions[2]['score']:.3f})")
            
            st.write("\n**Channel Effectiveness:**")
            for i, pred in enumerate(predictions[:3]):
                effectiveness = "High" if pred['score'] > 0 else "Medium" if pred['score'] > -1 else "Low"
                st.write(f"‚Ä¢ **{pred['channel']}**: {effectiveness} effectiveness")
            
            st.markdown("</div>", unsafe_allow_html=True)
            
            # Channel Preference Ranking in Horizontal Tiles
            st.subheader("üìà Channel Preference Ranking")
            
            # Create horizontal tiles
            st.markdown('<div class="horizontal-tile-container">', unsafe_allow_html=True)
            
            for i, pred in enumerate(predictions):
                rank_class = "tile-rank-1" if i == 0 else "tile-rank-2" if i == 1 else "tile-rank-3" if i == 2 else "tile-rank-other"
                
                rank_badge = "ü•á" if i == 0 else "ü•à" if i == 1 else "ü•â" if i == 2 else f"{i+1}"
                
                st.markdown(f"""
                <div class="channel-tile {rank_class}">
                    <div style="font-size: 1.5rem;">{rank_badge}</div>
                    <div>{pred['channel']}</div>
                    <div style="font-size: 0.8rem; margin-top: 5px;">{pred['score']:.3f}</div>
                </div>
                """, unsafe_allow_html=True)
            
            st.markdown('</div>', unsafe_allow_html=True)
            
            # Score Visualization
            st.subheader("üìä Score Visualization")
            
            # Create horizontal bar chart
            channels = [pred['channel'] for pred in predictions]
            scores = [pred['score'] for pred in predictions]
            
            # Standard Chartered color palette for charts
            sc_color_scale = [
                [0.0, '#D1D5DB'],   # Light gray for low scores
                [0.3, '#9CA3AF'],   # Medium gray
                [0.5, '#6B7280'],   # Dark gray  
                [0.7, '#4A90E2'],   # SC Light blue
                [0.9, '#0F4C99'],   # SC Blue
                [1.0, '#00B04F']    # SC Green for highest scores
            ]
            
            fig = px.bar(
                x=scores, 
                y=channels, 
                orientation='h',
                title="Channel Preference Scores",
                labels={'x': 'Prediction Score', 'y': 'Communication Channel'},
                color=scores,
                color_continuous_scale=sc_color_scale,
                text=[f"{score:.3f}" for score in scores]
            )
            
            fig.update_layout(
                height=400,
                yaxis={'categoryorder': 'total ascending'},
                showlegend=False,
                title_font_color='#0F4C99',
                title_font_size=16,
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)'
            )
            
            # Update axis colors
            fig.update_xaxes(gridcolor='#E5E7EB', title_font_color='#6B7280')
            fig.update_yaxes(title_font_color='#6B7280')
            
            fig.update_traces(textposition='outside')
            
            st.plotly_chart(fig, use_container_width=True)
    
    # Footer with Standard Chartered branding
    st.markdown("---")
    st.markdown("""
    <div style='background: linear-gradient(135deg, #0F4C99 0%, #00B04F 100%); 
                padding: 2rem; border-radius: 10px; text-align: center; margin-top: 2rem;'>
        <div style='color: white; font-size: 1.1rem; font-weight: bold; margin-bottom: 0.5rem;'>
            üè¶ Standard Chartered Bank
        </div>
        <div style='color: #E3F2FD; font-size: 0.9rem; margin-bottom: 0.5rem;'>
            AI-Powered Channel Prediction System
        </div>
        <div style='color: #B8E6B8; font-size: 0.8rem;'>
            Optimizing customer communication through machine learning ‚Ä¢ Powered by LightGBM, XGBoost & Random Forest
        </div>
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()