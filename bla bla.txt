import streamlit as st
import pandas as pd
import numpy as np
import joblib
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings
import io
warnings.filterwarnings('ignore')

# Set page config
st.set_page_config(
    page_title="Standard Chartered - Channel Prediction Model",
    page_icon="üè¶",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS with Standard Chartered branding
st.markdown("""
<style>
    /* Standard Chartered Brand Colors */
    :root {
        --sc-blue: #0F4C99;
        --sc-green: #00B04F;
        --sc-light-blue: #4A90E2;
        --sc-gray: #6B7280;
        --sc-light-gray: #F3F4F6;
        --sc-white: #FFFFFF;
    }
    
    /* Main Header */
    .main-header {
        font-size: 2.5rem;
        color: var(--sc-blue);
        text-align: center;
        margin-bottom: 1rem;
        font-weight: bold;
        font-family: 'Arial', sans-serif;
    }
    
    .sub-header {
        font-size: 1.2rem;
        color: var(--sc-gray);
        text-align: center;
        margin-bottom: 2rem;
        font-weight: 400;
    }
    
    /* Clean Card Styling */
    .clean-card {
        background-color: #FFFFFF;
        padding: 1.5rem;
        border-radius: 8px;
        border: 1px solid #E5E7EB;
        margin: 1rem 0;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    
    .prediction-card {
        background-color: #F8FAFF;
        padding: 1.5rem;
        border-radius: 8px;
        border: 1px solid #0F4C99;
        margin: 1rem 0;
    }
    
    .recommendation-card {
        background-color: #F0FDF4;
        padding: 1.5rem;
        border-radius: 8px;
        border: 1px solid #00B04F;
        margin: 1rem 0;
    }
    
    /* Button Styling */
    .stButton > button {
        background-color: var(--sc-blue);
        color: white;
        border-radius: 6px;
        border: none;
        font-weight: 500;
        transition: all 0.2s ease;
    }
    
    .stButton > button:hover {
        background-color: #0D3F80;
        box-shadow: 0 2px 4px rgba(15, 76, 153, 0.2);
    }
    
    .secondary-button > button {
        background-color: #6B7280;
        color: white;
    }
    
    .success-button > button {
        background-color: var(--sc-green);
        color: white;
    }
    
    /* Sidebar Styling */
    .sidebar .sidebar-content {
        background-color: #F8FAFC;
    }
    
    /* Horizontal channel tiles */
    .horizontal-tile-container {
        display: flex;
        gap: 10px;
        overflow-x: auto;
        padding: 10px 0;
        margin: 1rem 0;
    }
    
    .channel-tile {
        flex: 0 0 auto;
        width: 140px;
        padding: 12px;
        border-radius: 6px;
        text-align: center;
        font-weight: bold;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        border: 1px solid #E5E7EB;
    }
    
    .tile-rank-1 {
        background-color: #00B04F;
        color: white;
        border-color: #00B04F;
    }
    
    .tile-rank-2 {
        background-color: #0F4C99;
        color: white;
        border-color: #0F4C99;
    }
    
    .tile-rank-3 {
        background-color: #4A90E2;
        color: white;
        border-color: #4A90E2;
    }
    
    .tile-rank-other {
        background-color: #FFFFFF;
        color: #1F2937;
        border-color: #D1D5DB;
    }
    
    /* Batch prediction styling */
    .batch-section {
        background-color: #F8FAFC;
        padding: 1.5rem;
        border-radius: 8px;
        border: 1px solid #E5E7EB;
        margin: 1rem 0;
    }
    
    /* Metric Cards */
    [data-testid="metric-container"] {
        background-color: white;
        border: 1px solid #E5E7EB;
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid #00B04F;
    }
    
    /* Remove default streamlit padding */
    .element-container {
        margin-bottom: 0.5rem;
    }
</style>
""", unsafe_allow_html=True)

class ChannelPredictor:
    """Channel prediction system exactly like the notebook implementation"""
    
    def __init__(self):
        self.model = None
        self.model_data = None
        self.df = None
        self.channels = ['SMS', 'Email', 'Call', 'WhatsApp', 'IVR', 'Field_Agent']
        self.label_encoders = {}
        
    def load_model(self, model_path):
        """Load the trained model"""
        try:
            self.model_data = joblib.load(model_path)
            self.model = self.model_data['model']
            self.channels = self.model_data.get('channels', self.channels)
            self.label_encoders = self.model_data.get('label_encoders', {})
            return True
        except Exception as e:
            st.error(f"Error loading model: {str(e)}")
            return False
    
    def load_customer_data(self, data_path):
        """Load customer dataset"""
        try:
            self.df = pd.read_csv(data_path)
            return True
        except Exception as e:
            st.error(f"Error loading customer data: {str(e)}")
            return False
    
    def get_customer_by_id(self, customer_id):
        """Get customer data by ID with better error handling"""
        if self.df is None:
            return None, "Customer data not loaded"
        
        customer_data = self.df[self.df['Customer_id'] == customer_id]
        
        if customer_data.empty:
            # Suggest similar customer IDs
            similar_customers = self.df[
                self.df['Customer_id'].str.contains(customer_id[:6] if len(customer_id) > 6 else customer_id[:3], 
                                                   case=False, na=False)
            ]['Customer_id'].head(5).tolist()
            
            if similar_customers:
                return None, f"Customer ID '{customer_id}' not found! Did you mean: {', '.join(similar_customers)}?"
            else:
                # Show some random samples
                random_samples = self.df['Customer_id'].sample(5).tolist()
                return None, f"Customer ID '{customer_id}' not found! Try searching or use these samples: {', '.join(random_samples)}"
        
        return customer_data.iloc[0], None
    
    def prepare_features(self, customer_data):
        """Prepare features for prediction - exactly like notebook"""
        if isinstance(customer_data, pd.Series):
            customer_data = customer_data.to_frame().T
        
        # Get feature columns (exclude label and ID columns)
        exclude_cols = ['Customer_id', 'Channel_Preference_Order', 'Preference_Label', 'Top_Channel']
        exclude_cols.extend([col for col in customer_data.columns if 'Prefers_' in col])
        feature_cols = [col for col in customer_data.columns if col not in exclude_cols]
        
        # Extract customer features
        X_customer = customer_data[feature_cols].copy()
        
        # Handle categorical encoding if needed
        for col in X_customer.columns:
            if col in self.label_encoders:
                try:
                    X_customer[col] = self.label_encoders[col].transform([X_customer[col].iloc[0]])[0]
                except:
                    X_customer[col] = 0  # Default for unseen categories
        
        return X_customer.values.flatten(), feature_cols
    
    def predict_single_customer(self, customer_data):
        """Predict channel preferences for a single customer - exactly like notebook"""
        if isinstance(customer_data, pd.Series):
            customer_data = customer_data.to_frame().T
        
        customer_id = customer_data['Customer_id'].iloc[0]
        
        # Prepare customer features
        customer_features, feature_cols = self.prepare_features(customer_data)
        
        channel_predictions = []
        
        # Make predictions for each channel
        for i, channel in enumerate(self.channels):
            try:
                # Create channel one-hot encoding
                channel_features = np.zeros(len(self.channels))
                channel_features[i] = 1
                
                # Combine customer and channel features
                combined_features = np.concatenate([customer_features, channel_features])
                
                # Make prediction
                score = self.model.predict([combined_features])[0]
                
                channel_predictions.append({
                    'channel': channel,
                    'score': score,
                    'customer_id': customer_id
                })
                
            except Exception as e:
                # Default score if prediction fails
                channel_predictions.append({
                    'channel': channel,
                    'score': 0.0,
                    'customer_id': customer_id
                })
        
        # Sort channels by prediction score (descending)
        channel_predictions.sort(key=lambda x: x['score'], reverse=True)
        
        return channel_predictions
    
    def predict_batch(self, start_idx=0, end_idx=None):
        """Predict channel preferences for a range of customers"""
        if self.df is None:
            return None, "Customer data not loaded"
        
        if end_idx is None or end_idx > len(self.df):
            end_idx = len(self.df)
        
        customers_to_predict = self.df.iloc[start_idx:end_idx]
        results = []
        
        # Progress bar
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        for idx, (_, customer_row) in enumerate(customers_to_predict.iterrows()):
            # Update progress
            progress = (idx + 1) / len(customers_to_predict)
            progress_bar.progress(progress)
            status_text.text(f"Processing customer {idx + 1} of {len(customers_to_predict)}...")
            
            # Make prediction for this customer
            predictions = self.predict_single_customer(customer_row.to_frame().T)
            
            # Extract channel preferences in order
            channel_order = [pred['channel'] for pred in predictions]
            
            # Create result row
            result_row = {
                'Customer_ID': customer_row['Customer_id']
            }
            
            # Add each channel preference
            for i, channel in enumerate(channel_order, 1):
                result_row[f'{i}_Preferred_Channel'] = channel
            
            results.append(result_row)
        
        progress_bar.empty()
        status_text.empty()
        
        return pd.DataFrame(results), None
    
    def get_customer_insights(self, customer_data):
        """Get customer profile insights with proper z-score denormalization"""
        insights = {}
        if isinstance(customer_data, pd.Series):
            data = customer_data
        else:
            data = customer_data.iloc[0]
        
        # Basic customer info
        insights['Customer ID'] = data['Customer_id']
        
        # Age (z-score denormalized) - assuming mean=45, std=15 for banking customers
        if 'Age' in data:
            z_score = data['Age']
            estimated_age = int(45 + (z_score * 15))  # mean=45, std=15
            estimated_age = max(18, min(80, estimated_age))  # Clamp to realistic range
            insights['Estimated Age'] = estimated_age
        
        # Income Band (decode z-score normalized values)
        if 'Income_Band_SGD' in data:
            z_score = data['Income_Band_SGD']
            # Map z-scores to income bands (assuming normal distribution across 6 bands)
            if z_score < -1.5:
                income_band = "50,000 or Below"
            elif z_score < -0.5:
                income_band = "50,000 to 100,000"
            elif z_score < 0.0:
                income_band = "100,000 to 200,000"
            elif z_score < 0.5:
                income_band = "200,000 to 300,000"
            elif z_score < 1.0:
                income_band = "300,000 to 500,000"
            else:
                income_band = "500,000 or Above"
            insights['Income Band (SGD)'] = income_band
        
        # Location
        if 'Urban_Rural_Tag_Urban' in data:
            insights['Location'] = "Urban" if data['Urban_Rural_Tag_Urban'] == 1.0 else "Rural"
        
        # Language Preference
        if 'Language_Preference_English' in data and 'Language_Preference_Regional' in data:
            if data['Language_Preference_English'] == 1.0:
                insights['Language Preference'] = "English"
            elif data['Language_Preference_Regional'] == 1.0:
                insights['Language Preference'] = "Regional"
            else:
                insights['Language Preference'] = "Mixed/Other"
        
        # Digital Savviness (already 0-1 scale)
        if 'Digital_Savviness_Score' in data:
            savviness = data['Digital_Savviness_Score']
            if savviness >= 0.7:
                savviness_level = f"High ({savviness:.2f})"
            elif savviness >= 0.4:
                savviness_level = f"Medium ({savviness:.2f})"
            else:
                savviness_level = f"Low ({savviness:.2f})"
            insights['Digital Savviness'] = savviness_level
        
        # App Usage (raw values)
        if 'App_Login_Frequency' in data:
            insights['App Login Frequency'] = f"{int(data['App_Login_Frequency'])} times/month"
        
        if 'Online_Banking_Activity' in data:
            insights['Online Banking Activity'] = f"{int(data['Online_Banking_Activity'])} transactions/month"
        
        # Smartphone Usage
        if 'Smartphone_Penetration_High' in data:
            insights['Smartphone Usage'] = "High" if data['Smartphone_Penetration_High'] == 1.0 else "Low/Medium"
        
        # Customer Segment
        if 'Customer_Segment' in data:
            insights['Customer Segment'] = data['Customer_Segment']
        
        # Credit Score (z-score denormalized) - assuming mean=700, std=100
        if 'Credit_Score' in data:
            z_score = data['Credit_Score']
            estimated_score = int(700 + (z_score * 100))  # mean=700, std=100
            estimated_score = max(300, min(850, estimated_score))  # Clamp to realistic range
            insights['Estimated Credit Score'] = estimated_score
        
        # Loan Information (z-score denormalized) - assuming mean=100k, std=50k
        if 'Loan_Amount_SGD' in data:
            z_score = data['Loan_Amount_SGD']
            estimated_loan = int(100000 + (z_score * 50000))  # mean=100k, std=50k
            estimated_loan = max(10000, estimated_loan)  # Minimum 10k
            insights['Estimated Loan Amount (SGD)'] = f"{estimated_loan:,}"
        
        # Outstanding Balance (z-score denormalized) - assuming mean=50k, std=30k
        if 'Outstanding_Balance_SGD' in data:
            z_score = data['Outstanding_Balance_SGD']
            estimated_balance = int(50000 + (z_score * 30000))  # mean=50k, std=30k
            estimated_balance = max(0, estimated_balance)  # Minimum 0
            insights['Estimated Outstanding Balance (SGD)'] = f"{estimated_balance:,}"
        
        # Days Past Due (z-score denormalized) - assuming mean=15, std=10
        if 'Day_Past_Due' in data:
            z_score = data['Day_Past_Due']
            estimated_dpd = int(15 + (z_score * 10))  # mean=15, std=10
            estimated_dpd = max(0, estimated_dpd)  # Minimum 0 days
            insights['Days Past Due'] = estimated_dpd
        
        # Tenure (z-score denormalized) - assuming mean=36 months, std=18 months
        if 'Tenure' in data:
            z_score = data['Tenure']
            estimated_tenure = int(36 + (z_score * 18))  # mean=36, std=18
            estimated_tenure = max(1, estimated_tenure)  # Minimum 1 month
            insights['Estimated Tenure (Months)'] = estimated_tenure
        
        # Channel Response Rates (show top channels)
        channel_rates = {}
        for channel in ['SMS', 'Email', 'Call', 'WhatsApp', 'IVR', 'Field_Agent']:
            rate_col = f'Channel_{channel}_Response_Rate'
            if rate_col in data and data[rate_col] > 0:
                channel_rates[channel] = data[rate_col]
        
        if channel_rates:
            top_responsive_channel = max(channel_rates, key=channel_rates.get)
            insights['Most Responsive Channel'] = f"{top_responsive_channel} ({channel_rates[top_responsive_channel]:.3f})"
        
        # Actual preference order if available
        if 'Channel_Preference_Order' in data:
            insights['Actual Preference Order'] = data['Channel_Preference_Order']
        
        if 'Top_Channel' in data:
            insights['Current Top Channel'] = data['Top_Channel']
        
        return insights

def convert_df_to_csv(df):
    """Convert DataFrame to CSV for download"""
    return df.to_csv(index=False).encode('utf-8')

def main():
    # Clean main header without logo
    st.markdown('<h1 class="main-header">Channel Prediction System</h1>', unsafe_allow_html=True)
    st.markdown('<p class="sub-header">AI-Powered Customer Communication Channel Optimization</p>', unsafe_allow_html=True)
    
    # Initialize predictor
    predictor = ChannelPredictor()
    
    # Standard Chartered logo in sidebar
    logo_files = ["logo.svg", "standard_chartered_logo.png", "standard_chartered_logo.jpg", 
                  "sc_logo.png", "logo.png", "Standard_Chartered_logo.png"]
    logo_displayed = False
    
    for logo_file in logo_files:
        try:
            st.sidebar.image(logo_file, width=200)
            logo_displayed = True
            break
        except:
            continue
    
    if not logo_displayed:
        # Fallback display for sidebar
        st.sidebar.markdown("""
        <div style='text-align: center; padding: 1rem; margin-bottom: 1rem;'>
            <div style='font-family: Arial, sans-serif;'>
                <span style='color: #0F4C99; font-size: 1.8rem; font-weight: bold;'>Standard Chartered</span>
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # Sidebar for model selection
    st.sidebar.markdown("""
    <div style='background-color: #0F4C99; color: white; padding: 1rem; border-radius: 6px; margin-bottom: 1rem; text-align: center;'>
        <h3 style='color: white; margin: 0;'>Model Settings</h3>
    </div>
    """, unsafe_allow_html=True)
    
    # Model selection
    model_option = st.sidebar.selectbox(
        "Select Prediction Model:",
        ["LightGBM (Recommended)", "XGBoost", "Random Forest"]
    )
    
    model_files = {
        "LightGBM (Recommended)": "lightgbm_channel_ranker.pkl",
        "XGBoost": "xgb_channel_ranker.pkl", 
        "Random Forest": "random_forest_channel_ranker.pkl"
    }
    
    selected_model_file = model_files[model_option]
    
    # Load model and data
    if st.sidebar.button("üîÑ Load Model & Data", use_container_width=True):
        with st.spinner("Loading model and customer data..."):
            model_loaded = predictor.load_model(selected_model_file)
            data_loaded = predictor.load_customer_data('features_with_labels.csv')
            
            if model_loaded and data_loaded:
                st.sidebar.success(f"‚úÖ {model_option} loaded successfully!")
                st.sidebar.success(f"‚úÖ {len(predictor.df):,} customers loaded!")
                st.session_state.model_loaded = True
                st.session_state.current_model = model_option
                st.session_state.predictor = predictor
                
                # Show prediction type selection after loading
                st.session_state.show_prediction_type = True
            else:
                st.sidebar.error("‚ùå Failed to load model or data")
                st.session_state.model_loaded = False
                st.session_state.show_prediction_type = False
    
    # Check if model is loaded and show prediction type selection
    if hasattr(st.session_state, 'show_prediction_type') and st.session_state.show_prediction_type:
        st.markdown("---")
        st.subheader("Select Prediction Type")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üë§ Individual Prediction", use_container_width=True, type="primary"):
                st.session_state.prediction_type = "individual"
                st.rerun()
        
        with col2:
            if st.button("üìä Batch Prediction", use_container_width=True):
                st.session_state.prediction_type = "batch"
                st.rerun()
    
    # Handle batch prediction
    if hasattr(st.session_state, 'prediction_type') and st.session_state.prediction_type == "batch":
        st.markdown("---")
        st.subheader("üìä Batch Prediction")
        
        # Get predictor from session state
        predictor = st.session_state.predictor
        
        st.info("Generate channel predictions for multiple customers at once")
        
        # Batch prediction options
        st.markdown('<div class="batch-section">', unsafe_allow_html=True)
        st.write("**Prediction Range**")
        
        col1, col2 = st.columns(2)
        
        with col1:
            start_idx = st.number_input(
                "Start Index:",
                min_value=0,
                max_value=len(predictor.df)-1,
                value=0,
                help="Starting index of customers to process"
            )
        
        with col2:
            end_idx = st.number_input(
                "End Index:",
                min_value=1,
                max_value=len(predictor.df),
                value=min(1000, len(predictor.df)),
                help="Ending index of customers to process"
            )
        
        st.write(f"**Processing:** Customers {start_idx} to {end_idx} ({end_idx - start_idx} total)")
        
        # Run batch prediction
        if st.button("üöÄ Run Batch Prediction", type="primary", use_container_width=True):
            with st.spinner("Running batch predictions... This may take a few minutes."):
                batch_results, error = predictor.predict_batch(start_idx=start_idx, end_idx=end_idx)
                
                if error:
                    st.error(f"Error in batch prediction: {error}")
                else:
                    st.session_state.batch_results = batch_results
                    st.success(f"‚úÖ Batch prediction completed! Processed {len(batch_results):,} customers.")
        
        st.markdown('</div>', unsafe_allow_html=True)
        
        # Display batch results if available
        if hasattr(st.session_state, 'batch_results') and st.session_state.batch_results is not None:
            batch_results = st.session_state.batch_results
            
            st.markdown("---")
            st.subheader("üìã Batch Prediction Results")
            
            # Display statistics
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Customers Processed", f"{len(batch_results):,}")
            
            with col2:
                top_channel = batch_results['1_Preferred_Channel'].value_counts().index[0]
                st.metric("Most Common Top Channel", top_channel)
            
            with col3:
                unique_customers = batch_results['Customer_ID'].nunique()
                st.metric("Unique Customers", f"{unique_customers:,}")
            
            with col4:
                channels_covered = batch_results['1_Preferred_Channel'].nunique()
                st.metric("Channels Used", channels_covered)
            
            # Filter options for first preferred channel
            st.write("**Filter by First Preferred Channel:**")
            all_channels = ['All'] + sorted(batch_results['1_Preferred_Channel'].unique().tolist())
            selected_channel = st.selectbox("Select channel to filter:", all_channels)
            
            if selected_channel != 'All':
                filtered_results = batch_results[batch_results['1_Preferred_Channel'] == selected_channel]
                st.write(f"Showing {len(filtered_results)} customers with {selected_channel} as first preference")
            else:
                filtered_results = batch_results
            
            # Display sample of results
            st.write("**Prediction Results:**")
            st.dataframe(filtered_results.head(20), use_container_width=True)
            
            # Download buttons
            st.markdown("---")
            st.subheader("üì• Download Results")
            
            col1, col2 = st.columns(2)
            
            with col1:
                # Complete results download
                csv_complete = convert_df_to_csv(filtered_results)
                st.download_button(
                    label="üìÑ Download Filtered Results (CSV)",
                    data=csv_complete,
                    file_name=f"channel_predictions_{selected_channel.lower()}_{len(filtered_results)}_customers.csv",
                    mime="text/csv",
                    use_container_width=True
                )
            
            with col2:
                # All results download
                csv_all = convert_df_to_csv(batch_results)
                st.download_button(
                    label="üìä Download All Results (CSV)",
                    data=csv_all,
                    file_name=f"channel_predictions_all_{len(batch_results)}_customers.csv",
                    mime="text/csv",
                    use_container_width=True
                )
            
            # Visualize channel distribution
            st.markdown("---")
            st.subheader("üìà Channel Distribution")
            
            col1, col2 = st.columns(2)
            
            with col1:
                # Bar chart of top channel distribution
                channel_dist = batch_results['1_Preferred_Channel'].value_counts()
                fig_bar = px.bar(
                    x=channel_dist.values,
                    y=channel_dist.index,
                    orientation='h',
                    title="Top Preferred Channels",
                    labels={'x': 'Number of Customers', 'y': 'Channel'},
                    color=channel_dist.values,
                    color_continuous_scale=['#0F4C99', '#00B04F']
                )
                fig_bar.update_layout(
                    height=400,
                    showlegend=False,
                    plot_bgcolor='white'
                )
                st.plotly_chart(fig_bar, use_container_width=True)
            
            with col2:
                # Pie chart of channel distribution
                fig_pie = px.pie(
                    values=channel_dist.values,
                    names=channel_dist.index,
                    title="Channel Preference Distribution",
                    color_discrete_sequence=['#0F4C99', '#00B04F', '#4A90E2', '#6B7280', '#9CA3AF', '#D1D5DB']
                )
                fig_pie.update_layout(height=400)
                st.plotly_chart(fig_pie, use_container_width=True)
        
        # Back button
        if st.button("‚Üê Back to Prediction Type Selection"):
            st.session_state.prediction_type = None
            st.rerun()
        
        return
    
    # Individual prediction interface
    if hasattr(st.session_state, 'prediction_type') and st.session_state.prediction_type == "individual":
        # Get predictor from session state
        predictor = st.session_state.predictor
        
        # Search and prediction section
        st.markdown("---")
        
        # Create two columns for search and prediction button
        search_col, predict_col = st.columns([3, 1])
        
        with search_col:
            # Integrated search with advanced options
            customer_id_input = st.text_input(
                "üîç Search Customer ID:",
                value=st.session_state.get('selected_customer_id', ''),
                placeholder="Type any Customer ID (e.g., SCB251079598) or use advanced search below",
                help="Enter ANY Customer ID from the 100,000+ customers in the dataset"
            )
        
        with predict_col:
            st.write("")  # Spacer for alignment
            st.write("")  # Spacer for alignment
            if st.button("üéØ Predict", type="primary", use_container_width=True):
                if customer_id_input:
                    with st.spinner("Looking up customer and generating predictions..."):
                        # Get customer data
                        customer_data, error = predictor.get_customer_by_id(customer_id_input)
                        
                        if error:
                            st.error(error)
                        else:
                            # Make predictions
                            predictions = predictor.predict_single_customer(customer_data)
                            insights = predictor.get_customer_insights(customer_data)
                            
                            # Store in session state
                            st.session_state.predictions = predictions
                            st.session_state.customer_insights = insights
                            st.session_state.current_customer_id = customer_id_input
                            
                            st.success(f"‚úÖ Predictions generated for Customer {customer_id_input}!")
                else:
                    st.warning("Please enter a Customer ID")
        
        # Advanced search options
        with st.expander("üîç Advanced Search Options", expanded=True):
            col1, col2 = st.columns(2)
            
            with col1:
                # Filter by segment with descriptions
                if 'Customer_Segment' in predictor.df.columns:
                    segment_options = ['All'] 
                    # Add segment options with descriptions
                    if 'Young' in predictor.df['Customer_Segment'].unique():
                        segment_options.append('Young (18-30 years)')
                    if 'Senior' in predictor.df['Customer_Segment'].unique():
                        segment_options.append('Senior (60+ years)')
                    if 'Traditional' in predictor.df['Customer_Segment'].unique():
                        segment_options.append('Traditional (low digital engagement)')
                    if 'High Value Digital' in predictor.df['Customer_Segment'].unique():
                        segment_options.append('High Value Digital (digital savvy)')
                    if 'Standard' in predictor.df['Customer_Segment'].unique():
                        segment_options.append('Standard (default category)')
                    
                    # Add any other segments without descriptions
                    other_segments = [seg for seg in predictor.df['Customer_Segment'].unique() 
                                    if seg not in ['Young', 'Senior', 'Traditional', 'High Value Digital', 'Standard']]
                    segment_options.extend(other_segments)
                    
                    selected_segment = st.selectbox("Filter by Segment:", segment_options)
                else:
                    selected_segment = 'All'
            
            with col2:
                # Search by ID pattern
                id_pattern = st.text_input("Customer ID Pattern:", placeholder="e.g., SCB2*, *598, SCB*")
            
            # Search button
            if st.button("üîç Search Customers", use_container_width=True):
                # Apply filters and get matching customers
                filtered_df = predictor.df.copy()
                
                if selected_segment != 'All':
                    # Extract segment name without description
                    segment_name = selected_segment.split(' (')[0]
                    filtered_df = filtered_df[filtered_df['Customer_Segment'] == segment_name]
                
                if id_pattern:
                    # Convert pattern to regex
                    regex_pattern = id_pattern.replace('*', '.*')
                    filtered_df = filtered_df[
                        filtered_df['Customer_id'].str.contains(regex_pattern, case=False, na=False)
                    ]
                
                if len(filtered_df) > 0:
                    st.session_state.search_results = filtered_df['Customer_id'].head(30).tolist()
                    st.success(f"Found {len(filtered_df)} customers matching criteria")
                else:
                    st.warning("No customers found with these criteria")
            
            # Display search results if available
            if hasattr(st.session_state, 'search_results') and st.session_state.search_results:
                st.write("**Click any Customer ID below to select:**")
                
                # Display in a grid
                cols = st.columns(6)
                for i, customer_id in enumerate(st.session_state.search_results):
                    with cols[i % 6]:
                        if st.button(customer_id, key=f"search_btn_{customer_id}", use_container_width=True):
                            st.session_state.selected_customer_id = customer_id
                            st.rerun()
        
        # Quick validation
        if customer_id_input and predictor.df is not None:
            if customer_id_input in predictor.df['Customer_id'].values:
                st.success(f"‚úÖ Customer {customer_id_input} found in database!")
            elif len(customer_id_input) > 3:
                st.warning(f"‚ö†Ô∏è Customer {customer_id_input} not found. Check spelling or search above.")
        
        # Show dataset statistics
        st.info(f"üìä **Dataset Info:** {len(predictor.df):,} total customers available for prediction")
        
        # Prediction results container
        if hasattr(st.session_state, 'predictions') and st.session_state.predictions:
            st.markdown("---")
            st.subheader("üìä Prediction Results")
            
            # Display current model and customer
            st.info(f"ü§ñ Model: {st.session_state.current_model} | üë§ Customer: {st.session_state.current_customer_id}")
            
            # Customer Profile Details
            if hasattr(st.session_state, 'customer_insights'):
                st.markdown('<div class="clean-card">', unsafe_allow_html=True)
                st.subheader("üë§ Customer Profile")
                
                insights = st.session_state.customer_insights
                
                # Organize insights into categories (excluding channels)
                basic_info = {}
                financial_info = {}
                digital_info = {}
                
                for key, value in insights.items():
                    if key in ['Customer ID', 'Estimated Age', 'Location', 'Language Preference', 'Customer Segment']:
                        basic_info[key] = value
                    elif 'Loan' in key or 'Credit' in key or 'Balance' in key or 'Due' in key or 'Tenure' in key or 'Income' in key:
                        financial_info[key] = value
                    elif 'Digital' in key or 'App' in key or 'Online' in key or 'Smartphone' in key:
                        digital_info[key] = value
                
                # Display in organized columns
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.write("**Basic Information**")
                    for key, value in basic_info.items():
                        st.write(f"**{key}:** {value}")
                
                with col2:
                    st.write("**Financial Information**")
                    for key, value in financial_info.items():
                        st.write(f"**{key}:** {value}")
                
                with col3:
                    st.write("**Digital Profile**")
                    for key, value in digital_info.items():
                        st.write(f"**{key}:** {value}")
                
                st.markdown('</div>', unsafe_allow_html=True)
            
            # Primary Recommendation and Business Action Plan
            predictions = st.session_state.predictions
            top_channel = predictions[0]['channel']
            top_score = predictions[0]['score']
            
            # Primary Recommendation
            st.markdown('<div class="recommendation-card">', unsafe_allow_html=True)
            st.subheader("üéØ Primary Recommendation")
            st.write(f"**Contact via:** {top_channel}")
            st.write(f"**Confidence Score:** {top_score:.4f}")
            st.markdown('</div>', unsafe_allow_html=True)
            
            # Business Action Plan
            st.markdown('<div class="clean-card">', unsafe_allow_html=True)
            st.subheader("üíº Business Action Plan")
            
            st.write("**Recommended Contact Strategy:**")
            st.write(f"1. **Start with {predictions[0]['channel']}** - Highest success probability (Score: {predictions[0]['score']:.3f})")
            st.write(f"2. **Follow up with {predictions[1]['channel']}** - Second best option (Score: {predictions[1]['score']:.3f})")
            st.write(f"3. **Use {predictions[2]['channel']}** - Alternative if needed (Score: {predictions[2]['score']:.3f})")
            
            st.write("**Channel Effectiveness:**")
            for i, pred in enumerate(predictions[:3]):
                effectiveness = "High" if pred['score'] > 0 else "Medium" if pred['score'] > -1 else "Low"
                st.write(f"‚Ä¢ **{pred['channel']}**: {effectiveness} effectiveness")
            
            st.markdown('</div>', unsafe_allow_html=True)
            
            # Channel Preference Ranking in Horizontal Tiles
            st.subheader("üìà Channel Preference Ranking")
            
            # Create horizontal tiles
            st.markdown('<div class="horizontal-tile-container">', unsafe_allow_html=True)
            
            for i, pred in enumerate(predictions):
                rank_class = "tile-rank-1" if i == 0 else "tile-rank-2" if i == 1 else "tile-rank-3" if i == 2 else "tile-rank-other"
                
                rank_badge = "ü•á" if i == 0 else "ü•à" if i == 1 else "ü•â" if i == 2 else f"{i+1}"
                
                st.markdown(f"""
                <div class="channel-tile {rank_class}">
                    <div style="font-size: 1.5rem;">{rank_badge}</div>
                    <div>{pred['channel']}</div>
                    <div style="font-size: 0.8rem; margin-top: 5px;">{pred['score']:.3f}</div>
                </div>
                """, unsafe_allow_html=True)
            
            st.markdown('</div>', unsafe_allow_html=True)
            
            # Score Visualization
            st.subheader("üìä Score Visualization")
            
            # Create horizontal bar chart
            channels = [pred['channel'] for pred in predictions]
            scores = [pred['score'] for pred in predictions]
            
            fig = px.bar(
                x=scores, 
                y=channels, 
                orientation='h',
                title="Channel Preference Scores",
                labels={'x': 'Prediction Score', 'y': 'Communication Channel'},
                color=scores,
                color_continuous_scale=['#0F4C99', '#00B04F'],
                text=[f"{score:.3f}" for score in scores]
            )
            
            fig.update_layout(
                height=400,
                yaxis={'categoryorder': 'total ascending'},
                showlegend=False,
                plot_bgcolor='white',
                font=dict(color='#1F2937')
            )
            
            fig.update_traces(textposition='outside')
            
            st.plotly_chart(fig, use_container_width=True)
    
    # Footer with Standard Chartered logo
    st.markdown("---")
    
    # Try to display SVG logo in footer
    try:
        st.image("logo.svg", width=200)
    except:
        # Fallback footer
        st.markdown("""
        <div style='text-align: center; padding: 2rem; margin-top: 2rem;'>
            <div style='color: #0F4C99; font-size: 1.1rem; font-weight: bold; margin-bottom: 0.5rem;'>
                Standard Chartered Bank
            </div>
            <div style='color: #6B7280; font-size: 0.9rem;'>
                AI-Powered Channel Prediction System
            </div>
        </div>
        """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()